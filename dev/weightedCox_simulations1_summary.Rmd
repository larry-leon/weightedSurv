---
title: "Weighted Cox Simulations"
output: 
  html_document:
         code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, messages = FALSE)
rm(list=ls())
library(survival)
library(weightedsurv)
library(tinytex)

library(dplyr)
library(gt)
library(ggplot2)
library(tidyr)

```


# Load simulation results
```{r, include=TRUE}
# Note: revise to relevant location
# The simulations are run in batch mode and saved in results directory that is NOT uploaded to GitHub
# The code to run the simulations is "run_wCox_simulations1.r" in the vignettes directory
load("../vignettes/results/simulations1_25k.RData")
n_sim <- res_out$number_sims 
time_inhours <- res_out$thours
```



# Main 3 tests plot under various NPH scenarios via simtrial (need to include Keaven and others in authorship) 

Operating characteristics of the Log-rank, FH(0,1), and `zero-one` weighting where weights are zero in the first 6 months and one thereafter.  Note that under the NPH scenario of a 6-month late separation effect the `zero-one` weighting would be optimal in the sense of estimating the effect of therapy post 6-months.

### We focus on `zero-one` weighting

Where the weights are zero for time-points within 6 months and one thereafter.   In general, such time-dependent weighting is controversial, however `zero-one` type of weighting could be viable in 
scenarios where treatment is "not active" by design in terms of the timing of therapy administration --- as in *vaccine* trials. 


## Simulations
Simulations are based on `r prettyNum(n_sim, big.mark=",")` trials simulated for each scenario. Type-1 error upper bounds are `r round(0.025 + 1.96*sqrt(0.025*0.975/n_sim),4)` and 
`r round(0.05 + 1.96*sqrt(0.05*0.95/n_sim),4)` for $2.5\%$ (1-sided) and $5\%$ (2-sided) alpha-levels.   The computational time was `r round(time_inhours,2)` hours.


```{r}

# Get all column names in results_sims that contain 'z'
z_cols <- grep('z', colnames(res_out$results_sims), value = TRUE)
# Select Scenario and all z columns
df <- res_out$results_sims[, c('Scenario', z_cols)]
# Remove columns with 'debiased' from z_cols
z_cols_nondebiased <- z_cols[!grepl('debiased', z_cols)]
# Select Scenario and filtered z columns

z_main <- c('fh00z_mine', 'fh01z_mine', 't601z')

df2 <- res_out$results_sims[, c('Scenario', z_main)]

df2 <- df2 %>%
  group_by(Scenario) %>%
  rename(
    "log-rank" = fh00z_mine, 
    "FH(0,1)" = fh01z_mine,
    "0/1(6)" = t601z 
  ) 


# Reshape to long format
long_df2 <- tidyr::pivot_longer(df2, cols = -Scenario, names_to = 'z_stat', values_to = 'z_value')

# Create scenario_name mapping
scenario_labels <- c('PH', '3-month', '6-month', 'Crossing', 'Weak', 'Strong')
long_df2$scenario_name <- factor(long_df2$Scenario,
                                 levels = 1:6,
                                 labels = scenario_labels)

# Calculate prop_signif for annotation
ann_df <- long_df2 %>%
  group_by(scenario_name, z_stat) %>%
  summarise(prop_signif = mean(z_value > qnorm(0.975)), .groups = 'drop')

# Find minimum z_value for each facet to place annotation near the bottom
min_z <- long_df2 %>% group_by(z_stat) %>% summarise(min_z = min(z_value))
ann_df_ws <- ann_df %>% filter(scenario_name %in% c('Weak', 'Strong'))
ann_df_ws <- left_join(ann_df_ws, min_z, by = 'z_stat')
# Create annotation labels with leading and trailing zeros removed
ann_df_ws$label <- sub("^0+", "", sub("\\.?0+$", "", sprintf("%.3f", ann_df_ws$prop_signif)))

max_z <- long_df2 %>% group_by(z_stat) %>% summarise(max_z = max(z_value))
ann_df_Nonws <- ann_df %>% filter(!(scenario_name %in% c('Weak', 'Strong')))
ann_df_Nonws <- left_join(ann_df_Nonws, max_z, by = 'z_stat')
# Create annotation labels with leading and trailing zeros removed
ann_df_Nonws$label <- sub("^0+", "", sub("\\.?0+$", "", sprintf("%.3f", ann_df_Nonws$prop_signif)))

n_sim <- res_out$number_sims
pnull_threshold <- round(0.025 + 1.96*sqrt(0.025*0.975/n_sim),4)

# Set label color based on prop_signif > pnull_threshold
ann_df_ws$label_color <- ifelse(ann_df_ws$prop_signif > pnull_threshold, "red", "black")

ann_df_Nonws$label_color <- ifelse(ann_df_Nonws$prop_signif > 0.85, "purple", "grey")

# Merge prop_signif into long_df2 for correct fill
long_df2_fill <- left_join(long_df2, ann_df, by = c('scenario_name', 'z_stat'))

# Boxplot with fill mapped to prop_signif
p_fill <- ggplot(long_df2_fill, aes(x = scenario_name, y = z_value, fill = prop_signif)) +
  geom_boxplot(outlier.size = 0.2) +
  facet_wrap(~z_stat, scales = 'free_y') +
  labs(x = 'Scenario', y = 'Z value', title = 'Distribution of Z statistics by Scenario (box fill by prop_signif)', fill = 'Prop. Significant') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  scale_fill_gradient(low = 'pink', high = 'purple') +
  geom_hline(yintercept = qnorm(0.975), linetype = 'dashed', color = 'black', size = 0.5) +
  geom_text(data = ann_df_ws, aes(x = scenario_name, y = min_z, label = label, color = label_color),
            size = 3.5, fontface = 'bold', inherit.aes = FALSE, vjust = -0.5) +
  scale_color_identity() +
  geom_text(data = ann_df_Nonws, aes(x = scenario_name, y = max_z, label = label, color = label_color),
            size = 3.5, fontface = 'bold', inherit.aes = FALSE, vjust = 0.5) 

```



```{r, fig.width = 10, fig.height = 6}
print(p_fill)
```






# WLR and Wald tests (upper-bound < 1)

Correspondence between log-rank (weighted log-rank) and Wald (Cox model) tests

```{r}
results <- res_out$results_sims
results$Scenario <- factor(results$Scenario, levels = 1:6,
     labels = c("PH", "3m delay", "6m delay", "Crossing", "Weak null", "Strong null"))

table_gt <- results %>%
  group_by(Scenario) %>%
  summarise(
    Cox = mean(fh00_wald < 1.0),
    Logrank = mean(fh00z_mine > qnorm(0.975)),
    Cox01 = mean(fh01_wald < 1.0),
    FH01 = mean(fh01z_mine > qnorm(0.975)),        
    Cox601 = mean(t601_wald < 1.0),
    LR601 = mean(t601z > qnorm(0.975))
  ) |>
  gt() |> fmt_number(columns = 2:7, decimals = 3)  
  
table_gt2 <- table_gt %>%
  fmt_number(columns = 2:7, decimals = 3) %>%
  cols_label(
    Cox = "Wald",
    Logrank = "logrank",
    Cox01 = "Wald ",
    FH01 = "logrank ",
    Cox601 = "Wald  ",
    LR601 = "logrank  "
      ) %>%
  tab_spanner(
    label = "Standard Cox",
    columns = c("Cox", "Logrank")
  ) %>%
  tab_spanner(
    label = "FH(0,1)",
    columns = c("Cox01", "FH01")
  ) %>%
  tab_spanner(
    label = "zero/one(6)",
    columns = c("Cox601","LR601")
    ) 


table_gt3 <- table_gt2 %>%
  tab_style(
    style = cell_fill(color = "#D3D3D3"),  # light grey
    locations = cells_body(
      columns = "LR601",
      rows = Scenario == "6m delay"
    )
  )

table_gt4 <- table_gt3 %>%
  tab_style(
    style = cell_fill(color = "yellow"),  # light grey
    locations = cells_body(
      columns = "Logrank",
      rows = Scenario == "6m delay"
    )
  )


table_gt4


```


Operating characteristics of Cox hazard-ratio estimates and SE estimation

```{r}
results <- res_out$results_sims
results$Scenario <- factor(results$Scenario, levels = 1:6,
     labels = c("PH", "3m delay", "6m delay", "Crossing", "Weak null", "Strong null"))

table_gt <- results %>%
  group_by(Scenario) %>%
  summarise(
    Cox = mean(exp(fh00_bhat), na.rm=TRUE),
    Coxdb = mean(exp(fh00_bhatdebiased), na.rm=TRUE),
    se00 = sqrt(var(fh00_bhat, na.rm=TRUE)),
    se00h = mean(fh00_sigbhat, na.rm=TRUE),
    se00h_star = mean(fh00_sigbhatstar, na.rm = TRUE),
    t601 = mean(exp(t601_bhat), na.rm=TRUE),
    t601db = mean(exp(t601_bhatdebiased), na.rm=TRUE),
    set01 = sqrt(var(t601_bhat, na.rm=TRUE)),
    set01h = mean(t601_sigbhat, na.rm=TRUE),
    set01h_star = mean(t601_sigbhatstar, na.rm = TRUE)
  ) %>%
  rename(
    HR = Cox, 
    HR_db = Coxdb,
    SE = se00,
    SE_est = se00h,
    SE_db = se00h_star,
    HR2 = t601, 
    HR_db2 = t601db,
    SE2 = set01,
    SE_est2 = set01h,
    SE_db2 = set01h_star
  ) %>%
  gt() %>%
  fmt_number(columns = 2:11, decimals = 3) %>%
  cols_label(
    HR = "HR",
    HR_db = "db(HR)",
    HR2 = "HR ",
    HR_db2 = "db(HR) ",
    SE ="SE",
    SE_est = "est(SE)",
    SE_db ="est*(SE)",
    SE2 ="SE ",
    SE_est2 = "est(SE) ",
    SE_db2 ="est*(SE) "
      ) %>%
  tab_spanner(
    label = "Standard Cox Estimates",
    columns = c("HR", "HR_db", "SE","SE_est", "SE_db")
  ) %>%
  tab_spanner(
    label = "zero/one(6) Estimators",
    columns = c("HR2", "HR_db2", "SE2","SE_est2", "SE_db2")
    ) 


table_gt2 <- table_gt %>%
  tab_style(
    style = cell_fill(color = "#D3D3D3"),  # light grey
    locations = cells_body(
      columns = "HR2",
      rows = Scenario == "6m delay"
    )
  )

table_gt3 <- table_gt2 %>%
  tab_style(
    style = cell_fill(color = "yellow"),  # light grey
    locations = cells_body(
      columns = "HR",
      rows = Scenario == "6m delay"
    )
  )

table_gt3



```
       


# Main plot all FH versions

```{r}

# Get all column names in results_sims that contain 'z'
z_cols <- grep('z', colnames(res_out$results_sims), value = TRUE)
# Select Scenario and all z columns
df <- res_out$results_sims[, c('Scenario', z_cols)]
# Remove columns with 'debiased' from z_cols
z_cols_nondebiased <- z_cols[!grepl('debiased', z_cols)]
# Select Scenario and filtered z columns

z_main <- c('fh00z_mine', 'fh05z_mine', 'fh01z_mine',
            'mb6z_mine', 'mb12z_mine', 'fhe1z', 'fhe2z', 't601z')


df2 <- res_out$results_sims[, c('Scenario', z_main)]

# Reshape to long format
long_df2 <- tidyr::pivot_longer(df2, cols = -Scenario, names_to = 'z_stat', values_to = 'z_value')

# Create scenario_name mapping
scenario_labels <- c('PH', '3-month', '6-month', 'Crossing', 'Weak', 'Strong')
long_df2$scenario_name <- factor(long_df2$Scenario,
                                 levels = 1:6,
                                 labels = scenario_labels)

# Calculate prop_signif for annotation
ann_df <- long_df2 %>%
  group_by(scenario_name, z_stat) %>%
  summarise(prop_signif = mean(z_value > qnorm(0.975)), .groups = 'drop')

# Find minimum z_value for each facet to place annotation near the bottom
min_z <- long_df2 %>% group_by(z_stat) %>% summarise(min_z = min(z_value))
ann_df_ws <- ann_df %>% filter(scenario_name %in% c('Weak', 'Strong'))
ann_df_ws <- left_join(ann_df_ws, min_z, by = 'z_stat')
# Create annotation labels with leading and trailing zeros removed
ann_df_ws$label <- sub("^0+", "", sub("\\.?0+$", "", sprintf("%.3f", ann_df_ws$prop_signif)))

max_z <- long_df2 %>% group_by(z_stat) %>% summarise(max_z = max(z_value))
ann_df_Nonws <- ann_df %>% filter(!(scenario_name %in% c('Weak', 'Strong')))
ann_df_Nonws <- left_join(ann_df_Nonws, max_z, by = 'z_stat')
# Create annotation labels with leading and trailing zeros removed
ann_df_Nonws$label <- sub("^0+", "", sub("\\.?0+$", "", sprintf("%.3f", ann_df_Nonws$prop_signif)))

n_sim <- res_out$number_sims
pnull_threshold <- round(0.025 + 1.96*sqrt(0.025*0.975/n_sim),4)

# Set label color based on prop_signif > 0.0264
ann_df_ws$label_color <- ifelse(ann_df_ws$prop_signif > 0.0264, "red", "black")

ann_df_Nonws$label_color <- ifelse(ann_df_Nonws$prop_signif > 0.85, "purple", "grey")

# Merge prop_signif into long_df2 for correct fill
long_df2_fill <- left_join(long_df2, ann_df, by = c('scenario_name', 'z_stat'))

# Boxplot with fill mapped to prop_signif
p_fill <- ggplot(long_df2_fill, aes(x = scenario_name, y = z_value, fill = prop_signif)) +
  geom_boxplot(outlier.size = 0.2) +
  facet_wrap(~z_stat, scales = 'free_y') +
  labs(x = 'Scenario', y = 'Z value', title = 'Distribution of Z statistics by Scenario (box fill by prop_signif)', fill = 'Prop. Significant') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  scale_fill_gradient(low = 'yellow', high = 'lightblue') +
  geom_hline(yintercept = qnorm(0.975), linetype = 'dashed', color = 'black', size = 0.5) +
  geom_text(data = ann_df_ws, aes(x = scenario_name, y = min_z, label = label, color = label_color),
            size = 3.5, fontface = 'bold', inherit.aes = FALSE, vjust = -0.5) +
  scale_color_identity() +
  geom_text(data = ann_df_Nonws, aes(x = scenario_name, y = max_z, label = label, color = label_color),
            size = 3.5, fontface = 'bold', inherit.aes = FALSE, vjust = 0.5) 

#print(p_fill)
```



```{r, fig.width = 12, fig.height = 8}
print(p_fill)
```

# Checking alignment with simtrial

```{r, warning = FALSE, message = FALSE}
# We now go back to the entire simulation results to compare 
# log-rank z-statistics with those of simtrial
# z-statistics with extension "_mine" vs simtrial

# Get all column names in results_sims that contain 'z'
z_cols <- grep('z', colnames(res_out$results_sims), value = TRUE)
# Select Scenario and all z columns
df <- res_out$results_sims[, c('Scenario', z_cols)]
# Remove columns with 'debiased' from z_cols
z_cols_nondebiased <- z_cols[!grepl('debiased', z_cols)]
# Select Scenario and filtered z columns
df2 <- res_out$results_sims[, c('Scenario', z_cols_nondebiased)]
# Reshape to long format
long_df2 <- tidyr::pivot_longer(df2, cols = -Scenario, names_to = 'z_stat', values_to = 'z_value')

# Custom order: group main and _mine variants together
# For example logrankz denotes simtrial log-rank and fh00z_mine is based on weightedsurv

z_main <- c('logrankz', 'fh00z_mine', 'fh05z', 'fh05z_mine','fh01z', 'fh01z_mine',
            'mb6z', 'mb6z_mine', 'mb12z', 'mb12z_mine', 'fhe1z', 'fhe2z', 't601z')

# Only keep those present in z_cols_nondebiased
z_order2 <- z_main[z_main %in% z_cols_nondebiased]
# Add any remaining columns not in z_main
z_order2 <- c(z_order2, setdiff(z_cols_nondebiased, z_order2))
# Set factor levels for facet order
long_df2$z_stat <- factor(long_df2$z_stat, levels = z_order2)

# Create scenario_name mapping
scenario_labels <- c('PH', '3-month', '6-month', 'Crossing', 'Weak', 'Strong')
long_df2$scenario_name <- factor(long_df2$Scenario,
                                 levels = 1:6,
                                 labels = scenario_labels)

# Calculate prop_signif for annotation
ann_df <- long_df2 %>%
  group_by(scenario_name, z_stat) %>%
  summarise(prop_signif = mean(z_value > qnorm(0.975)), .groups = 'drop')

# Find minimum z_value for each facet to place annotation near the bottom
min_z <- long_df2 %>% group_by(z_stat) %>% summarise(min_z = min(z_value))
ann_df_ws <- ann_df %>% filter(scenario_name %in% c('Weak', 'Strong'))
ann_df_ws <- left_join(ann_df_ws, min_z, by = 'z_stat')

# Create annotation labels with leading and trailing zeros removed
ann_df_ws$label <- sub("^0+", "", sub("\\.?0+$", "", sprintf("%.3f", ann_df_ws$prop_signif)))

n_sim <- res_out$number_sims
pnull_threshold <- round(0.025 + 1.96*sqrt(0.025*0.975/n_sim),4)

# Set label color based on prop_signif > 0.0264
ann_df_ws$label_color <- ifelse(ann_df_ws$prop_signif > 0.0264, "red", "black")

# Merge prop_signif into long_df2 for correct fill
long_df2_fill <- left_join(long_df2, ann_df, by = c('scenario_name', 'z_stat'))

# Boxplot with fill mapped to prop_signif
p_fill <- ggplot(long_df2_fill, aes(x = scenario_name, y = z_value, fill = prop_signif)) +
  geom_boxplot(outlier.size = 0.2) +
  facet_wrap(~z_stat, scales = 'free_y') +
  labs(x = 'Scenario', y = 'Z value', title = 'Distribution of Z statistics by Scenario (box fill by prop_signif)', fill = 'Prop. Significant') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  scale_fill_gradient(low = 'yellow', high = 'lightblue') +
  geom_hline(yintercept = qnorm(0.975), linetype = 'dashed', color = 'black', size = 0.5) +
  geom_text(data = ann_df_ws, aes(x = scenario_name, y = min_z, label = label, color = label_color),
            size = 3.5, fontface = 'bold', inherit.aes = FALSE, vjust = -0.5) +
  scale_color_identity()

```



```{r, fig.width = 12, fig.height = 8}
print(p_fill)
```




